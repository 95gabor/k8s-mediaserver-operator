name: Check for App Version Updates

on:
  schedule:
    # Run every day at 8 AM UTC
    - cron: "0 8 * * *"
  workflow_dispatch:

jobs:
  check-updates:
    runs-on: ubuntu-24.04
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Run pre-commit
        uses: pre-commit/action@v3.0.1

      - name: Install dependencies
        run: |
          pip install pyyaml requests

      - name: Check for updates
        id: check
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python << 'EOF'
          import yaml
          import requests
          import os
          import json
          from pathlib import Path

          charts_dir = Path("charts")
          updates = []

          # Define chart update logic
          chart_configs = {
              "jackett": {
                  "repo": "Jackett/Jackett",
                  "tag_format": "version",  # Uses version tags like "0.24.429"
                  "docker_format": "version"
              },
              "jellyfin": {
                  "repo": "jellyfin/jellyfin",
                  "tag_format": "version",  # Uses version tags like "10.11.4"
                  "docker_format": "version"
              },
              "sonarr": {
                  "repo": "Sonarr/Sonarr",
                  "tag_format": "version_base",  # Uses base version like "4.0.16" (not "4.0.16.2944")
                  "docker_format": "base_version"
              },
              "radarr": {
                  "repo": "Radarr/Radarr",
                  "tag_format": "version_base",  # Uses base version like "6.0.4" (not "6.0.4.10291")
                  "docker_format": "base_version"
              },
              "prowlarr": {
                  "repo": "Prowlarr/Prowlarr",
                  "tag_format": "version_base",  # Uses base version like "2.3.0" (not "2.3.0.5236")
                  "docker_format": "base_version"
              },
              "sabnzbd": {
                  "repo": "sabnzbd/sabnzbd",
                  "tag_format": "version",  # Uses version tags like "4.5.5"
                  "docker_format": "version"
              },
              "seerr": {
                  "repo": "seerr-team/seerr",
                  "tag_format": "container_registry",  # Container images are built from CI commits, not release commits
                  "docker_format": "commit_hash",
                  "container_registry": "ghcr.io/seerr-team/seerr"  # Check container registry for actual tags
              },
              "transmission": {
                  "repo": "transmission/transmission",
                  "tag_format": "version",  # Uses version tags like "4.0.6"
                  "docker_format": "version"
              }
          }

          def get_latest_release(repo):
              """Get latest release from GitHub"""
              url = f"https://api.github.com/repos/{repo}/releases/latest"
              response = requests.get(url)
              if response.status_code == 200:
                  return response.json()
              return None

          def get_commit_hash_from_release(release):
              """Extract commit hash from release"""
              if not release:
                  return None

              # Try target_commitish first
              if "target_commitish" in release:
                  commit_ref = release["target_commitish"]
                  # If it's already a commit hash (40 chars), use it
                  if len(commit_ref) == 40:
                      return commit_ref[:7]

              # If target_commitish is a branch/tag, get commit from the tag
              if "tag_name" in release:
                  tag_name = release["tag_name"]
                  repo = release.get("url", "").split("/repos/")[1].split("/releases")[0] if "/repos/" in release.get("url", "") else None
                  if repo:
                      # Get commit SHA from the tag
                      tag_url = f"https://api.github.com/repos/{repo}/git/refs/tags/{tag_name}"
                      tag_response = requests.get(tag_url)
                      if tag_response.status_code == 200:
                          tag_data = tag_response.json()
                          if "object" in tag_data and "sha" in tag_data["object"]:
                              return tag_data["object"]["sha"][:7]
                      # Alternative: try to get from commits API
                      commits_url = f"https://api.github.com/repos/{repo}/commits/{tag_name}"
                      commits_response = requests.get(commits_url)
                      if commits_response.status_code == 200:
                          commit_data = commits_response.json()
                          if "sha" in commit_data:
                              return commit_data["sha"][:7]

              return None

          def extract_base_version(version_string):
              """Extract base version from full version string"""
              # e.g., "4.0.16.2944" -> "4.0.16"
              parts = version_string.split(".")
              if len(parts) >= 3:
                  return ".".join(parts[:3])
              return version_string

          def get_latest_container_tag(container_registry):
              """Get latest container image tag from GitHub Container Registry"""
              # GHCR API requires authentication, so we use the GitHub Packages API
              # Format: https://api.github.com/orgs/{org}/packages/container/{package}/versions
              if not container_registry:
                  return None

              # Parse registry URL: ghcr.io/org/package -> org/package
              parts = container_registry.replace("ghcr.io/", "").split("/")
              if len(parts) != 2:
                  return None

              org, package = parts

              # Get package versions from GitHub API (use GITHUB_TOKEN if available)
              url = f"https://api.github.com/orgs/{org}/packages/container/{package}/versions"
              headers = {"Accept": "application/vnd.github+json"}
              token = os.environ.get("GITHUB_TOKEN")
              if token:
                  headers["Authorization"] = f"Bearer {token}"

              response = requests.get(url, headers=headers)

              if response.status_code == 200:
                  versions = response.json()
                  # Filter for tags that start with "sha-" and sort by updated_at
                  sha_tags = []
                  for version in versions:
                      if "metadata" in version and "container" in version["metadata"]:
                          tags = version["metadata"]["container"].get("tags", [])
                          for tag in tags:
                              if tag.startswith("sha-"):
                                  sha_tags.append({
                                      "tag": tag,
                                      "updated_at": version.get("updated_at", "")
                                  })

                  if sha_tags:
                      # Sort by updated_at (most recent first)
                      sha_tags.sort(key=lambda x: x["updated_at"], reverse=True)
                      return sha_tags[0]["tag"]
              else:
                  print(f"âš ï¸  Failed to fetch container tags: {response.status_code} - {response.text[:200]}")

              return None

          for chart_name in chart_configs.keys():
              chart_path = charts_dir / chart_name / "Chart.yaml"
              if not chart_path.exists():
                  continue

              with open(chart_path, 'r') as f:
                  chart_data = yaml.safe_load(f)

              current_app_version = chart_data.get("appVersion", "")
              config = chart_configs[chart_name]

              release = get_latest_release(config["repo"])
              if not release:
                  continue

              latest_tag = release["tag_name"].lstrip("v")  # Remove 'v' prefix if present

              # Format the version based on chart requirements
              if config["tag_format"] == "container_registry":
                  # For Seerr: Container images are built from CI commits, not release commits
                  # Check the container registry for the latest available tag
                  container_registry = config.get("container_registry")
                  latest_version = get_latest_container_tag(container_registry)
                  if not latest_version:
                      print(f"âš ï¸  {chart_name}: Could not find container registry tags, skipping")
                      continue
              elif config["tag_format"] == "commit_hash":
                  commit_hash = get_commit_hash_from_release(release)
                  if commit_hash:
                      latest_version = f"sha-{commit_hash}"
                  else:
                      continue
              elif config["tag_format"] == "version_base":
                  latest_version = extract_base_version(latest_tag)
              else:
                  latest_version = latest_tag

              if latest_version != current_app_version:
                  updates.append({
                      "chart": chart_name,
                      "current": current_app_version,
                      "latest": latest_version,
                      "release_url": release["html_url"]
                  })
                  print(f"ðŸ“¦ {chart_name}: {current_app_version} -> {latest_version}")

          if updates:
              print(f"\nâœ… Found {len(updates)} updates available")
              with open("updates.json", "w") as f:
                  json.dump(updates, f, indent=2)
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write(f"has_updates=true\n")
                  f.write(f"updates_count={len(updates)}\n")
          else:
              print("âœ… All charts are up to date")
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write("has_updates=false\n")
          EOF

      - name: Show updates
        if: steps.check.outputs.has_updates == 'true'
        run: |
          echo "## Available Updates" >> $GITHUB_STEP_SUMMARY
          cat updates.json | python -m json.tool >> $GITHUB_STEP_SUMMARY

      - name: Update chart versions
        if: steps.check.outputs.has_updates == 'true'
        run: |
          python << 'EOF'
          import yaml
          import json
          from pathlib import Path

          charts_dir = Path("charts")

          with open("updates.json", "r") as f:
              updates = json.load(f)

          for update in updates:
              chart_path = charts_dir / update["chart"] / "Chart.yaml"
              with open(chart_path, 'r') as f:
                  chart_data = yaml.safe_load(f)

              chart_data["appVersion"] = update["latest"]
              # Bump chart version patch
              version_parts = chart_data["version"].split(".")
              version_parts[-1] = str(int(version_parts[-1]) + 1)
              chart_data["version"] = ".".join(version_parts)

              with open(chart_path, 'w') as f:
                  yaml.dump(chart_data, f, default_flow_style=False, sort_keys=False)

              print(f"Updated {update['chart']}: {update['current']} -> {update['latest']}")
          EOF

      - name: Prepare PR body and commit message
        if: steps.check.outputs.has_updates == 'true'
        id: pr_info
        run: |
          python << 'EOF'
          import json
          import os

          with open("updates.json", "r") as f:
              updates = json.load(f)

          # Generate commit message list
          commit_lines = []
          for update in updates:
              commit_lines.append(f"- {update['chart']}: {update['current']} -> {update['latest']}")

          # Generate PR body
          body_lines = ["Automated update of application versions.", ""]
          for update in updates:
              body_lines.append(f"- **{update['chart']}**: {update['current']} â†’ {update['latest']} ([release]({update['release_url']}))")
          body_lines.append("")
          body_lines.append("This PR was automatically created by the check-updates workflow.")

          commit_msg = "chore: update app versions\n\n" + "\n".join(commit_lines)
          pr_body = "\n".join(body_lines)

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              # Use EOF delimiter for multiline output
              f.write(f"commit_message<<EOF\n{commit_msg}\nEOF\n")
              f.write(f"pr_body<<EOF\n{pr_body}\nEOF\n")
          EOF

      - name: Clean up temporary files
        if: steps.check.outputs.has_updates == 'true'
        run: |
          rm -f updates.json

      - name: Run pre-commit hooks
        if: steps.check.outputs.has_updates == 'true'
        run: pre-commit run --all-files || pre-commit run --all-files

      - name: Set current date
        if: steps.check.outputs.has_updates == 'true'
        id: date
        run: echo "date=$(date +'%Y-%m-%d')" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        if: steps.check.outputs.has_updates == 'true'
        uses: peter-evans/create-pull-request@v8
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: ${{ steps.pr_info.outputs.commit_message }}
          title: "chore: update app versions ${{ steps.date.outputs.date }}"
          body: ${{ steps.pr_info.outputs.pr_body }}
          branch: bump/app-versions
          sign-commits: true
          delete-branch: true
          labels: |
            automated
            dependencies
