name: Check for App Version Updates

on:
    schedule:
        # Run weekly on Monday at 9 AM UTC
        - cron: "0 9 * * 1"
    workflow_dispatch:
        inputs:
            update_charts:
                description: "Auto-update charts and create PR (true/false)"
                required: false
                default: "false"
                type: string

jobs:
    check-updates:
        runs-on: ubuntu-24.04
        permissions:
            contents: read
            pull-requests: write

        steps:
            - name: Checkout Code
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Set up Python
              uses: actions/setup-python@v5
              with:
                  python-version: "3.x"

            - name: Install dependencies
              run: |
                  pip install pyyaml requests

            - name: Check for updates
              id: check
              run: |
                  python << 'EOF'
                  import yaml
                  import requests
                  import os
                  import json
                  from pathlib import Path

                  charts_dir = Path("charts")
                  updates = []

                  # Define chart update logic
                  chart_configs = {
                      "jackett": {
                          "repo": "Jackett/Jackett",
                          "tag_format": "version",  # Uses version tags like "0.24.429"
                          "docker_format": "version"
                      },
                      "jellyfin": {
                          "repo": "jellyfin/jellyfin",
                          "tag_format": "version",  # Uses version tags like "10.11.4"
                          "docker_format": "version"
                      },
                      "sonarr": {
                          "repo": "Sonarr/Sonarr",
                          "tag_format": "version_base",  # Uses base version like "4.0.16" (not "4.0.16.2944")
                          "docker_format": "base_version"
                      },
                      "radarr": {
                          "repo": "Radarr/Radarr",
                          "tag_format": "version_base",  # Uses base version like "6.0.4" (not "6.0.4.10291")
                          "docker_format": "base_version"
                      },
                      "prowlarr": {
                          "repo": "Prowlarr/Prowlarr",
                          "tag_format": "version_base",  # Uses base version like "2.3.0" (not "2.3.0.5236")
                          "docker_format": "base_version"
                      },
                      "sabnzbd": {
                          "repo": "sabnzbd/sabnzbd",
                          "tag_format": "version",  # Uses version tags like "4.5.5"
                          "docker_format": "version"
                      },
                      "seerr": {
                          "repo": "seerr-team/seerr",
                          "tag_format": "commit_hash",  # Uses commit hash like "sha-e842036"
                          "docker_format": "commit_hash"
                      },
                      "transmission": {
                          "repo": "transmission/transmission",
                          "tag_format": "version",  # Uses version tags like "4.0.6"
                          "docker_format": "version"
                      }
                  }

                  def get_latest_release(repo):
                      """Get latest release from GitHub"""
                      url = f"https://api.github.com/repos/{repo}/releases/latest"
                      response = requests.get(url)
                      if response.status_code == 200:
                          return response.json()
                      return None

                  def get_commit_hash_from_release(release):
                      """Extract commit hash from release"""
                      if release and "target_commitish" in release:
                          return release["target_commitish"][:7]  # First 7 chars
                      return None

                  def extract_base_version(version_string):
                      """Extract base version from full version string"""
                      # e.g., "4.0.16.2944" -> "4.0.16"
                      parts = version_string.split(".")
                      if len(parts) >= 3:
                          return ".".join(parts[:3])
                      return version_string

                  for chart_name in chart_configs.keys():
                      chart_path = charts_dir / chart_name / "Chart.yaml"
                      if not chart_path.exists():
                          continue

                      with open(chart_path, 'r') as f:
                          chart_data = yaml.safe_load(f)

                      current_app_version = chart_data.get("appVersion", "")
                      config = chart_configs[chart_name]

                      release = get_latest_release(config["repo"])
                      if not release:
                          continue

                      latest_tag = release["tag_name"].lstrip("v")  # Remove 'v' prefix if present

                      # Format the version based on chart requirements
                      if config["tag_format"] == "commit_hash":
                          commit_hash = get_commit_hash_from_release(release)
                          if commit_hash:
                              latest_version = f"sha-{commit_hash}"
                          else:
                              continue
                      elif config["tag_format"] == "version_base":
                          latest_version = extract_base_version(latest_tag)
                      else:
                          latest_version = latest_tag

                      if latest_version != current_app_version:
                          updates.append({
                              "chart": chart_name,
                              "current": current_app_version,
                              "latest": latest_version,
                              "release_url": release["html_url"]
                          })
                          print(f"ðŸ“¦ {chart_name}: {current_app_version} -> {latest_version}")

                  if updates:
                      print(f"\nâœ… Found {len(updates)} updates available")
                      with open("updates.json", "w") as f:
                          json.dump(updates, f, indent=2)
                      with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                          f.write(f"has_updates=true\n")
                          f.write(f"updates_count={len(updates)}\n")
                  else:
                      print("âœ… All charts are up to date")
                      with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                          f.write("has_updates=false\n")
                  EOF

            - name: Show updates
              if: steps.check.outputs.has_updates == 'true'
              run: |
                  echo "## Available Updates" >> $GITHUB_STEP_SUMMARY
                  cat updates.json | python -m json.tool >> $GITHUB_STEP_SUMMARY

            - name: Install GitHub CLI
              if: steps.check.outputs.has_updates == 'true' && github.event.inputs.update_charts == 'true'
              run: |
                  type -p curl >/dev/null || apt install curl -y
                  curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
                  chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
                  echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null
                  apt update
                  apt install gh -y

            - name: Create update PR
              if: steps.check.outputs.has_updates == 'true' && github.event.inputs.update_charts == 'true'
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  git config user.name "github-actions[bot]"
                  git config user.email "github-actions[bot]@users.noreply.github.com"

                  BRANCH="update-app-versions-$(date +%Y%m%d)"
                  git checkout -b "$BRANCH"

                  python << 'EOF'
                  import yaml
                  import json
                  from pathlib import Path

                  charts_dir = Path("charts")

                  with open("updates.json", "r") as f:
                      updates = json.load(f)

                  for update in updates:
                      chart_path = charts_dir / update["chart"] / "Chart.yaml"
                      with open(chart_path, 'r') as f:
                          chart_data = yaml.safe_load(f)

                      chart_data["appVersion"] = update["latest"]
                      # Bump chart version patch
                      version_parts = chart_data["version"].split(".")
                      version_parts[-1] = str(int(version_parts[-1]) + 1)
                      chart_data["version"] = ".".join(version_parts)

                      with open(chart_path, 'w') as f:
                          yaml.dump(chart_data, f, default_flow_style=False, sort_keys=False)

                      print(f"Updated {update['chart']}: {update['current']} -> {update['latest']}")
                  EOF

                  git add charts/*/Chart.yaml
                  git commit -m "chore: update app versions

                  $(cat updates.json | python -c "import sys, json; updates = json.load(sys.stdin); print('\n'.join([f'- {u[\"chart\"]}: {u[\"current\"]} -> {u[\"latest\"]}' for u in updates]))")"

                  git push origin "$BRANCH"

                  gh pr create \
                    --title "chore: update app versions" \
                    --body "Automated update of application versions.

                  $(cat updates.json | python -c "import sys, json; updates = json.load(sys.stdin); print('\n'.join([f'- **{u[\"chart\"]}**: {u[\"current\"]} â†’ {u[\"latest\"]} ([release]({u[\"release_url\"]}))' for u in updates]))")

                  This PR was automatically created by the check-updates workflow." \
                    --base main

            - name: Install GitHub CLI
              if: steps.check.outputs.has_updates == 'true' && github.event.inputs.update_charts == 'true'
              run: |
                  type -p curl >/dev/null || apt install curl -y
                  curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
                  chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
                  echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | tee /etc/apt/sources.list.d/github-cli.list > /dev/null
                  apt update
                  apt install gh -y
